package bot;

import java.io.IOException;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;

import org.javacord.api.entity.message.embed.EmbedBuilder;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.ParseException;

public class User implements Serializable { //contains information about a user
    private static final long serialVersionUID = -9043245141882684605L; //autogenerated for file storage
    
    private long id; //the user's discord id
    private int dmojRating, dmojPN, cfRating, cfPN, dmojMax, cfMax, cfPP; //statistics about the user for codeforces and dmoj
    private double dmojPoints, dmojPP; //statistics about the user for codeforces and dmoj
    private String dmojName, cfName, realName, oiCheckList; //links to the user's dmoj, codeforces, oichecklist accounts and real life name
    private HashMap < String, UserProblem > problemList = new HashMap < String, UserProblem > (); //the problems in the user's to do list
    
    public User(long id) {
        this.id = id; //sets user id
        cfName = dmojName = realName = oiCheckList = ""; //initializes names as empty strings
        dmojPoints = dmojPP = dmojRating = dmojPN = cfRating = cfPN = dmojMax = cfMax = cfPP = 0; //initializes user's statistics as 0
    }
    
    public void addProblem(UserProblem newProblem) { //adds a problem to the user's to do list
        problemList.put(newProblem.getLink(), newProblem);
    }
    
    //getter methods for instance variables
    public long getId() {
        return id;
    }
    public int getDmojRating() {
        return dmojRating;
    }
    public int getDmojPN() {
        return dmojPN;
    }
    public int getcfRating() {
        return cfRating;
    }
    public int getCfPN() {
        return cfPN;
    }
    public int getDmojMax() {
        return dmojMax;
    }
    public int getCfMax() {
        return cfMax;
    }
    public int getCfPP() {
        return cfPP;
    }
    public double getDmojPoints() {
        return dmojPoints;
    }
    public double getDmojPP() {
        return dmojPP;
    }
    public int getTotalPN() {
        return dmojPN + cfPN;
    }
    public String getDmojName() {
        return dmojName;
    }
    public String getCfName() {
        return cfName;
    }

    public String setProblem(String problem, String status) { //modifies a problem in the list to a new status, given the link of the problem (String problem)
        if (!problemList.containsKey(problem)) problemList.put(problem, new UserProblem(problem, status)); //if the problem is not yet in the list, add it
        else problemList.get(problem).setStatus(status); //otherwise change its status
        return problemList.get(problem).toString(); //return the problem that was modified
    }
    
    public void setRealName(String name) { //sets the user's real life name
        realName = name;
    }
    
    public void setOiCheckList(String link) { //sets the user's oichecklist account
        oiCheckList = link;
    }
    
    public boolean setDmojName(String name) { //sets the user's dmoj account, returns whether it is successful
        JSONObject info;
        try {
            if (name.isEmpty()) { //if the name is empty, reset all of the dmoj statistics and account name
                dmojName = name;
                dmojPoints = dmojPP = dmojRating = dmojPN = dmojMax = 0;
                return true;
            }
            info = (JSONObject)((JSONObject) DmojCfApi.query("https://dmoj.ca/api/v2/user/" + name).get("data")).get("object"); //get info about user through dmoj api
            //sets dmoj statistics from the information
            dmojRating = ((Long) info.get("rating")).intValue();
            dmojPoints = (double) info.get("points");
            dmojPP = (double) info.get("performance_points");
            dmojPN = ((Long) info.get("problem_count")).intValue();
            JSONArray contests = (JSONArray) info.get("contests"); //get list of the user's contests
            dmojMax = dmojRating; //set the max rating to the current rating initially
            for (int i = 0; i < contests.size(); i++) //iterate through all of the user's contest history, find the max rating throughout all the contests
                if (((JSONObject) contests.get(i)).get("rating") != null)
                    dmojMax = (int) Math.max(dmojMax, (long)((JSONObject) contests.get(i)).get("rating"));
            dmojName = name; //sets the account name
            return true; //returns true as the account was successfully set
        } catch (IOException | ParseException | InterruptedException e) { //if the dmoj account could not be accessed, return false
            System.err.println("Error accessing dmoj account, username [" + name + "] may be invalid");
            return false;
        }
    }
    
    public boolean setCfName(String name) { //sets the user's codeforces account, returns whether it was successful
        JSONObject info;
        try {
            if (name.isEmpty()) { //if the name is empty, reset all of the codeforces statistics to zero and clear account name
                cfName = name;
                cfRating = cfPN = cfMax = cfPP = 0;
                return true;
            }
            info = (JSONObject)((JSONArray) DmojCfApi.query("https://codeforces.com/api/user.info?handles=" + name).get("result")).get(0); //get info about user on codeforces
            ArrayList < JSONObject > submissions = (ArrayList < JSONObject > ) DmojCfApi.query("https://codeforces.com/api/user.status?handle=" + name).get("result"); //get all the user's submissions
            HashSet < String > problems = new HashSet < String > (); //A set of the user's solved problems
            cfPP = 0;
            for (JSONObject cur: submissions) //iterates through all submissions and adds solved problems to the set while calculating a point score
                if (cur.get("verdict").equals("OK") && //if the submission fully solved a problem
                    problems.add(((JSONObject) cur.get("problem")).get("contestId") + (String)((JSONObject) cur.get("problem")).get("index")) && //add the problem to the set
                    ((JSONObject) cur.get("problem")).get("rating") != null) //if the problem is rated and not already in the set, it will contribute to the user's performance points
                    cfPP += (int) Math.pow(2, (long)((JSONObject) cur.get("problem")).get("rating") / 300.0 - 2);
            //sets other codeforces statistics for the user
            cfRating = ((Long) info.get("rating")).intValue();
            cfMax = ((Long) info.get("maxRating")).intValue();
            cfPN = problems.size();
            cfName = name;
            return true; //returns true, as no problems have occured
        } catch (IOException | ParseException | NullPointerException | InterruptedException e) { //if the codeforces account could not be accessed, return false
            System.err.println("Error accessing codeforces account, username [" + name + "] may be invalid");
            return false;
        }
    }
    
    public String toString() { //returns a string representing the user
        return "User " + Long.toString(id);
    }
    
    public EmbedBuilder showInfo() { //returns an embed displaying information about the user
        EmbedBuilder embed = new EmbedBuilder();
        if (!realName.isEmpty()) embed.addField("Real name", realName); //displays user's real name if it has been set
        if (!oiCheckList.isEmpty()) embed.addField("OI checklist", oiCheckList); //displays user's oichecklist link if it has been set
        if (!dmojName.isEmpty()) //displays user's dmoj name and statistics if it has been set
            embed.addField("DMOJ", "Name: " + dmojName + "|Rating: " + dmojRating + "/" + dmojMax + "|Points:" + Math.round(dmojPP) + "/" + Math.round(dmojPoints) + "|Problems solved: " + dmojPN);
        if (!cfName.isEmpty()) //displays user's codeforces name and statistics if it has been set
            embed.addField("Codeforces", "Name: " + cfName + "|Rating: " + cfRating + "/" + cfMax + "|Points: " + cfPP + "|Problems solved: " + cfPN);
        return embed;
    }
    
    public String removeProblem(String problem) { //given a problem link, removes a problem from the user's problem list
        if (problemList.containsKey(problem)) return problemList.remove(problem).toString(); //if the problem was in the list, remove it and return its string representation
        return null; //otherwise return null value
    }
    
    public void clearProblems() { //removes all problems from the user's problem list
        problemList.clear();
    }
    
    public ArrayList < UserProblem > getProblems(String status, String platform, String order) { //gets a user's problem list with options to filter by status, platform, and order by difficulty
        ArrayList < UserProblem > ret = new ArrayList < UserProblem > (); //the list of problems that match the filter
        for (UserProblem problem: problemList.values()) //iterates through all problems in the to do list
            if ((status == null || status.equalsIgnoreCase(problem.getStatus())) && //if the status filter has been set, check if the problem's status matches
                (platform == null || platform.equalsIgnoreCase(problem.getPlatform()))) //if the platform filter has been set, check if the problem comes from the appropriate platform
                ret.add(problem); //add the problem to the output list
        if ("easiest".equalsIgnoreCase(order)) Collections.sort(ret); //sort the list by ascending difficulty if specified by user
        else if ("hardest".equalsIgnoreCase(order)) { //sort the list by descending difficulty if specified by user
            Collections.sort(ret); //sorts the problems in ascending difficulty
            Collections.reverse(ret); //reverses the problems to reverse the list order
        }
        return ret; //returns the output list
    }
}