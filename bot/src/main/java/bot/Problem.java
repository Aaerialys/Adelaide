package bot;

import java.io.Serializable;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;

import org.json.simple.JSONObject;

public class Problem implements Comparable < Problem > , Serializable { //contains information about a problem
    private static final long serialVersionUID = -5704718188359731980L; //autogenerated for storage as a file
    
    private static final int[][] DMOJ_VS_CF = {
        {
            1,
            3,
            4,
            5,
            7,
            10,
            12,
            15,
            17,
            20,
            25,
            30,
            35,
            40,
            50
        }, //an array containing dmoj point difficulties and their equivalent codeforces ratings
        {
            50,
            300,
            600,
            1000,
            1300,
            1600,
            1900,
            2150,
            2350,
            2650,
            3050,
            3300,
            3400,
            3700,
            3800
        }
    };
    private String link, platform, title,code; //the link, platform, and title of the problem
    private int difficulty; //the difficulty of the problem, in terms of points for dmoj problems and rating for codeforces problems
    HashSet<String> tags;
    public Problem(JSONObject info,String p) {
    	platform=p;
    	if(info==null) return;
    	if(platform.equals("dmoj")) {
    		code=(String) info.get("code");
    		link="https://dmoj.ca/problem/"+code;
    		title=(String) info.get("name");
    		tags=new HashSet<String>();
    		Collection<String> temp=(Collection<String>) info.get("types");
    		for(String cur:temp) tags.add(cur.toLowerCase());
    		difficulty=((Double) info.get("points")).intValue();
    	}
    	else if(platform.equals("codeforces")) {
    		code=info.get("contestId")+(String)info.get("index");
    		for(int contest=((Long) info.get("contestId")).intValue();contest<10000;contest*=10) code="-"+code;
    		link="https://codeforces.com/problemset/problem/"+info.get("contestId")+"/"+info.get("index");
    		title=(String) info.get("name");
    		tags=new HashSet<String>();
    		Collection<String> temp=(Collection<String>) info.get("tags");
    		for(String cur:temp) tags.add(cur.toLowerCase());
    		if(info.containsKey("rating")) difficulty=((Long) info.get("rating")).intValue();
    	}
    }
    public Problem(String link) { //constructs a new problem from its link
        this.link = new String(link);
        difficulty = 0; //initializes the difficulty as 0
        title = null;
        if (link.contains("codeforces.")) { //if the link is from codeforces
            platform = "codeforces"; //set the platform to codeforces
            try {
                int contest = Integer.parseInt(link.substring(0, link.lastIndexOf('/')).replaceAll("[^\\d]", "")); //gets the problem's contest from the link
                String index = link.substring(link.lastIndexOf('/') + 1); //gets the problem's index from the link
                Problem info = DmojCfApi.cfProblemInfo(contest, index); //gets problem info from codeforces
                if (info == null) return; //if the problem was not found in the cache, exit
                title = (String) info.getTitle(); //set the problem title
                difficulty = info.getDifficulty(); //set the problem rating if it exists
            } catch (Exception e) { //if there was an error parsing or accessing the link on codeforces, exit
                System.err.println("Problem could not be found on codeforces: " + link);
                e.printStackTrace();
            }
        } else if (link.contains("dmoj.")) { //if the link is from dmoj
            platform = "dmoj";
            try {
                Problem info = DmojCfApi.dmojProblemInfo(link.substring(link.lastIndexOf('/') + 1)); //get problem info from dmoj
                if (info == null) return; //if the problem was not found, exit
                title = (String) info.getTitle(); //set the problem's name
                difficulty = info.getDifficulty(); //sets the problem's point value
            } catch (Exception e) { //if the problem could not be parsed or accessed on dmoj, exit
                System.err.println("Problem could not be found on dmoj" + link);
                e.printStackTrace();
            }
        } else platform = "other"; //otherwise set the platform to other
    }
    //getter methods for instance variables
    public String getLink() {
        return link;
    }
    public String getTitle() {
    	return title;
    }
    public String getPlatform() {
        return platform;
    }
    public String getCode() {
    	return code;
    }
    public int getDifficulty() {
        return difficulty;
    }
    public boolean containsTag(String tag) {
    	if(code.equals("2dperm")) for(String cur:tags) System.out.println(cur);
    	return tags.contains(tag);
    }
    
    public static int dmojToCf(int val) { //converts a dmoj point value to a codeforces rating difficulty by binary searching on the values table
        return DMOJ_VS_CF[1][Math.max(0, Arrays.binarySearch(DMOJ_VS_CF[0], val))];
    }
    
    public String toString() { //outputs a string representing the problem
        String ret = "";
        if (title == null) ret += "<" + link + ">";
        else ret += title;
        ret += " [" + platform + "]";
        return ret;
    }
    
    public String toStringEmbed() { //outputs a string representing the problem, formatted for discord embeds
        String ret = "";
        if (title == null) ret += "<" + link + ">";
        else ret += "[" + title + "](" + link + ")";
        ret += " [" + platform + "]";
        return ret;
    }
    @Override
    public int compareTo(Problem p) { //compares problems by difficulty for sorting purposes
        int a = difficulty, b = p.getDifficulty(); //get the difficutly of both problems
        if (platform.equals("dmoj")) a = dmojToCf(a); //if a problem is from dmoj, convert its point value to a codeforces rating
        if (p.getPlatform().equals("dmoj")) b = dmojToCf(b);
        return a - b; //returns a negative value if the this problem is less difficult than the other problem, positive if this problem is more difficult, and 0 if they are equal
    }
}